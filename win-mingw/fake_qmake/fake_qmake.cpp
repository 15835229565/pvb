// This is the qmake fake for windows
// These poor people haven't any good tools
// The fake is more than simple
// You can't compare it with qmake
#include <stdio.h>
#include <string.h>
#include "rlspreadsheet.h"
#define LEN 1024
static char infile[LEN]  = "";
static char outfile[LEN] = "";
static char line[LEN]    = "";
static char target[LEN]  = "";
static int ih   = 1;
static int icpp = 1;
static int ilib = 1;
static int iinc = 1;
static rlSpreadsheetRow h;
static rlSpreadsheetRow cpp;
static rlSpreadsheetRow lib;
static rlSpreadsheetRow inc;

static const char *get(const char *l, const char *tag, char *result)
{
  static char buf[LEN];
  int i;
  const char *found;

  *result = '\0';
  found = strstr(l,tag);
  if(found == NULL) return NULL;
  buf[0] = '\0';
  
  while(*found != ' ' && *found != '\t') found--;
  found++;
  i = 0;
  while(*found != ' ' && *found != '\t' && *found != '\n' && *found != '\0') { buf[i++] = *found++; buf[i] = '\0'; }
  //printf("found = %s\n",buf);
  strcpy(result,buf);  
  return found;
}

static int parse()
{
  FILE *in;
  const char *cptr;
  char name[LEN];
  int  mingw;
  
  mingw = 0;
  name[0] = '\0';
  in = fopen(infile,"r");
  if(in == NULL) return 0;
  
  while(fgets(line,sizeof(line)-1,in) != NULL)
  {
    if(strncmp(line,"win32-g++",9) == 0) mingw = 1;
    if(strncmp(line,"else",4)      == 0) mingw = 0;
    cptr = &line[0];
    while(cptr != NULL)
    {
      cptr = get(cptr,".h",name);
      if(cptr != NULL) h.printf(ih++,"%s",name);
    }
    cptr = &line[0];
    while(cptr != NULL)
    {
      cptr = get(cptr,".cpp",name);
      if(cptr != NULL) cpp.printf(icpp++,"%s",name);
    }
    if(strncmp(line,"LIBS",4) == 0)
    {
      cptr = &line[0];
      while(cptr != NULL)
      {
        cptr = get(cptr,".lib",name);
        if(cptr != NULL) lib.printf(ilib++,"%s",name);
      }
    }  
    else if(strncmp(line,"win32:LIBS",10) == 0 && mingw == 0)
    {
      cptr = &line[0];
      while(cptr != NULL)
      {
        cptr = get(cptr,".lib",name);
        if(cptr != NULL) lib.printf(ilib++,"%s",name);
      }
    }  
    if(strncmp(line,"TARGET = ",9) == 0) sscanf(line,"TARGET = %s",target);
    if((strncmp(line,"INCLUDEPATH",11) == 0) || (strncmp(line,"win32:INCLUDEPATH",17) == 0))
    {
      if(mingw == 0)
      {
        cptr = strstr(line,"=");
        if(cptr != NULL)
        {
          sscanf(cptr,"= %s",name);
          inc.printf(iinc++,"%s",name);
        }
      }  
    }
  }
  h.printf(ih,"#");
  cpp.printf(icpp,"#");
  lib.printf(ilib,"#");
  inc.printf(iinc,"#");
  fclose(in);
  return 1;
}

static const char *obj(const char *cpp)
{
  static char buf[LEN];
  char *cptr;
  
  strcpy(buf,cpp);
  cptr = strstr(buf,".cpp");
  if(cptr != NULL) strcpy(cptr,".obj");
  return buf;
}

static int generate()
{
  FILE *out;
  int i;
  
  out = fopen(outfile,"w");
  if(out == NULL) return -1;
  //for(i=1; i<ih;   i++) fprintf(out,"h:%s\n",h.text(i));
  //for(i=1; i<icpp; i++) fprintf(out,"cpp:%s\n",cpp.text(i));
  //for(i=1; i<ilib; i++) fprintf(out,"lib:%s\n",lib.text(i));
  //for(i=1; i<iinc; i++) fprintf(out,"inc:%s\n",inc.text(i));
  //fprintf(out,"target:%s\n",target);

  fprintf(out,"%s\n","# generated by fake_qmake.exe");    
  fprintf(out,"%s\n","####### Compiler, tools and options");
  fprintf(out,"%s\n","");
  fprintf(out,"%s\n","CC    = cl");
  fprintf(out,"%s\n","CXX   = cl");
  fprintf(out,"%s\n","LEX   = flex");
  fprintf(out,"%s\n","YACC    = byacc");
  fprintf(out,"%s\n","CFLAGS  = -nologo -Zm200 -W3 -O1 -DUNICODE -D_CRT_SECURE_NO_WARNINGS");
  fprintf(out,"%s\n","CXXFLAGS  = -nologo -Zm200 -W3 -O1 -DUNICODE -D_CRT_SECURE_NO_WARNINGS");
  fprintf(out,"%s\n","LEXFLAGS  =");
  fprintf(out,"%s\n","YACCFLAGS =-d");
  fprintf(out,"%s","INCPATH =");
  for(i=1; i<iinc; i++) fprintf(out," -I\"%s\"",inc.text(i));
  fprintf(out,"\n");
  fprintf(out,"%s\n","LINK  = link");
  //fprintf(out,"%s\n","LFLAGS  = /NODEFAULTLIB:LIBCD /NOLOGO delayimp.lib /DELAYLOAD:wsock32.dll /SUBSYSTEM:console");
  fprintf(out,"%s\n","LFLAGS  = /NODEFAULTLIB:LIBC /NODEFAULTLIB:LIBCMT /NOLOGO delayimp.lib /DELAYLOAD:wsock32.dll /SUBSYSTEM:console");
  //fprintf(out,"%s\n","LFLAGS  = /NOLOGO delayimp.lib /DELAYLOAD:comdlg32.dll /DELAYLOAD:oleaut32.dll /DELAYLOAD:winmm.dll /DELAYLOAD:wsock32.dll /DELAYLOAD:winspool.dll /SUBSYSTEM:console /incremental:no");
  fprintf(out,"%s","LIBS  = \"advapi32.lib\"");
  for(i=1; i<ilib; i++) fprintf(out," \"%s\"", lib.text(i));
  fprintf(out,"\n");
  fprintf(out,"%s\n","COPY_FILE =       copy");
  fprintf(out,"%s\n","COPY_DIR  =       copy");
  fprintf(out,"%s\n","DEL_FILE  =       del");
  fprintf(out,"%s\n","DEL_DIR =       rmdir");
  fprintf(out,"%s\n","MOVE    =       move");
  fprintf(out,"%s\n","CHK_DIR_EXISTS =  if not exist");
  fprintf(out,"%s\n","MKDIR   = mkdir");
  fprintf(out,"%s\n","");
  fprintf(out,"%s\n","####### Files");
  fprintf(out,"%s\n","");
  fprintf(out,"%s","HEADERS =");
  for(i=1; i<ih; i++) 
  {
    if(i==1) fprintf(out," %s",h.text(i));
    else     fprintf(out," \\\n    %s",h.text(i));
  }
  fprintf(out,"\n");
  fprintf(out,"%s","SOURCES =");
  for(i=1; i<icpp; i++) 
  {
    if(i==1) fprintf(out," %s",cpp.text(i));
    else     fprintf(out," \\\n    %s",cpp.text(i));
  }
  fprintf(out,"\n");
  fprintf(out,"%s","OBJECTS = ");
  for(i=1; i<icpp; i++) 
  {
    if(i==1) fprintf(out," %s",obj(cpp.text(i)));
    else     fprintf(out," \\\n    %s",obj(cpp.text(i)));
  }
  fprintf(out,"\n");
  fprintf(out,"%s\n","DIST  ="); 
  fprintf(out,"TARGET  = %s.exe\n",target);
  fprintf(out,"\n");
  fprintf(out,"%s\n","####### Implicit rules");
  fprintf(out,"\n");
  fprintf(out,"%s\n",".SUFFIXES: .c .cpp .cc .cxx .C");
  fprintf(out,"\n");
  fprintf(out,"%s\n","{.}.cpp{}.obj::");
  fprintf(out,"%s\n","  $(CXX) -c $(CXXFLAGS) $(INCPATH) -Fo @<<");
  fprintf(out,"%s\n","  $<");
  fprintf(out,"%s\n","<<");
  fprintf(out,"\n");
  fprintf(out,"%s\n","{.}.cc{}.obj::");
  fprintf(out,"%s\n","  $(CXX) -c $(CXXFLAGS) $(INCPATH) -Fo @<<");
  fprintf(out,"%s\n","  $<");
  fprintf(out,"%s\n","<<");
  fprintf(out,"\n");
  fprintf(out,"%s\n","{.}.cxx{}.obj::");
  fprintf(out,"%s\n","  $(CXX) -c $(CXXFLAGS) $(INCPATH) -Fo @<<");
  fprintf(out,"%s\n","  $<");
  fprintf(out,"%s\n","<<");
  fprintf(out,"\n");
  fprintf(out,"%s\n","{.}.C{}.obj::");
  fprintf(out,"%s\n","  $(CXX) -c $(CXXFLAGS) $(INCPATH) -Fo @<<");
  fprintf(out,"%s\n","  $<");
  fprintf(out,"%s\n","<<");
  fprintf(out,"\n");
  fprintf(out,"%s\n","{.}.c{}.obj::");
  fprintf(out,"%s\n","  $(CC) -c $(CFLAGS) $(INCPATH) -Fo @<<");
  fprintf(out,"%s\n","  $<");
  fprintf(out,"%s\n","<<");
  fprintf(out,"\n");
  fprintf(out,"%s\n","####### Build rules");
  fprintf(out,"\n");
  fprintf(out       ,"all: %s $(TARGET)\n",outfile);
  fprintf(out,"\n");
  fprintf(out,"%s\n","$(TARGET): $(OBJECTS)"); 
  fprintf(out,"%s\n","  $(LINK) $(LFLAGS) /OUT:$(TARGET) @<<"); 
  fprintf(out,"%s\n","    $(OBJECTS) $(LIBS)");
  fprintf(out,"%s\n","<<");
  fprintf(out,"\n");
  fprintf(out,"\n");
  fprintf(out,"%s\n","FORCE:");
  fprintf(out,"\n");
  fprintf(out,"%s\n","####### Compile");
  fprintf(out,"\n");
  for(i=1; i<icpp; i++)
  {
    fprintf(out,"%s: %s",obj(cpp.text(i)),cpp.text(i));
    for(int j=1; j<ih; j++) fprintf(out," %s",h.text(j));
    fprintf(out,"\n\n");
  }
  fprintf(out,"\n");
  
  fclose(out);
  return 0;
}

int main(int ac, char **av)
{
  int i;
  const char *arg;
  
  if(ac < 2) return -1;
  strcpy(outfile,"Makefile");
  for(i=1; i<ac; i++)
  {
    arg = av[i];
    if(strcmp(arg,"-o") == 0)
    {
      i++;
      arg = av[i];
      strcpy(outfile,arg);
    }
    else
    {
      strcpy(infile,arg);
    }
  }
  if(parse()) generate();
  else printf("error parsing %s\n",infile);
  return 0;
}
